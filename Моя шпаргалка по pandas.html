<!DOCTYPE html>
<!-- saved from url=(0028)https://3-info.ru/post/12111 -->
<html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Моя шпаргалка по pandas</title>
    <link rel="stylesheet" type="text/css" href="./Моя шпаргалка по pandas_files/style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Yandex.Metrika counter -->
        <script type="text/javascript" src="./Моя шпаргалка по pandas_files/context.js.Без названия" async=""></script><script async="" src="./Моя шпаргалка по pandas_files/tag.js.Без названия"></script><script type="text/javascript">
           (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
           m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
           (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

           ym(55168747, "init", {
                clickmap:true,
                trackLinks:true,
                accurateTrackBounce:true
           });
        </script>
        <noscript><div><img src="https://mc.yandex.ru/watch/55168747" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
        <script data-ad-client="ca-pub-9100872048126145" async="" src="./Моя шпаргалка по pandas_files/f.txt"></script>
        <script src="./Моя шпаргалка по pandas_files/particles.js.Без названия"></script>
        <!-- /Yandex.Metrika counter -->
</head>
<body>
    <div class="container fdc">
     <div class="menu_links">
      <a class="menu_link" href="https://3-info.ru/">Обратно</a>
      </div>
       

       <div id="particles-js">

           <a href="https://3-info.ru/telegram" class="p-text"><img class="p-img" src="./Моя шпаргалка по pandas_files/t.png"><div class="">Наш телеграм канал<div class="p-small">Будьте вкурсе новостей науки и IT</div></div></a>
       <canvas class="particles-js-canvas-el" width="1170" height="200" style="width: 100%; height: 100%;"></canvas></div>
       <style>
           .menu_links {
               width: 100%;
               margin: 10px 0;
           }
           .menu_link {
               /*text-decoration: none;*/
               /*cursor: pointer;*/
               /*color: #333;*/
               /*font-weight: 600;*/
               /*margin: 10px;*/

               text-align: center;
               width: 100px;
               border-radius: 5px;
               -webkit-box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.2);
               -moz-box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.2);
               box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.2);
               padding: 10px;
               color: #666;
               cursor: pointer;
               font-size: 14px;
           }
           .menu_link:hover {
               -webkit-box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.3);
               -moz-box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.3);
               box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.3);
               color: #444;
           }
           #particles-js {
               position: relative;
               width: 100%;
               height: 200px;
               background: #fff;
               margin-bottom: 20px;
               border-radius: 5px;
               margin-top: 5px;
           }
           .p-text {
               text-decoration: none;
               position: absolute;
               height: 200px;
               top:0;
               left: 0;
               width: 100%;
               display: flex;
               align-items: center;
               justify-content: center;
               z-index: 10;
               color: #333;
               font-weight: 400;
               font-size: 24px;
           }
           .p-small {
               font-size: 14px;
           }
           .p-img {
               width: 80px;
           }
        </style>
       
       <div class="header">Моя шпаргалка по pandas</div>
       

       
       <div class="content">Один преподаватель как-то сказал мне, что если поискать аналог программиста в мире книг, то окажется, что программисты похожи не на учебники, а на оглавления учебников: они не помнят всего, но знают, как быстро найти то, что им нужно.<br>
<br>
Возможность быстро находить описания функций позволяет программистам продуктивно работать, не теряя состояния потока. Поэтому я и создал представленную здесь шпаргалку по <code>pandas</code> и включил в неё то, чем пользуюсь каждый день, создавая веб-приложения и модели машинного обучения.<br>
<br>
<a href="https://habr.com/ru/company/ruvds/blog/494720/"><img src="./Моя шпаргалка по pandas_files/geybiuurbhpsffn2pu04xhax_rq.jpeg"></a><br>
<br>
Нельзя сказать, что это — исчерпывающий список возможностей <code>pandas</code>, но сюда входят функции, которыми я пользуюсь чаще всего, примеры и мои пояснения по поводу ситуаций, в которых эти функции особенно полезны.<br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF">1. Подготовка к работе</font></h2>
<br>
Если вы хотите самостоятельно опробовать то, о чём тут пойдёт речь, загрузите набор данных <a href="https://www.kaggle.com/CooperUnion/anime-recommendations-database">Anime Recommendations Database</a> с Kaggle. Распакуйте его и поместите в ту же папку, где находится ваш Jupyter Notebook (далее — блокнот).<br>
<br>
Теперь выполните следующие команды.<br>
<br>
<pre><code class="python">import pandas as pd
import numpy as np
anime = pd.read_csv('anime-recommendations-database/anime.csv')
rating = pd.read_csv('anime-recommendations-database/rating.csv')
anime_modified = anime.set_index('name')
</code></pre>
<br>
После этого у вас должна появиться возможность воспроизвести то, что я покажу в следующих разделах этого материала.<br>
<br>
<h2><font color="#3AC1EF">2. Импорт данных</font></h2>
<br>
<h3><font color="#3AC1EF">▍Загрузка CSV-данных</font></h3>
<br>
Здесь я хочу рассказать о преобразовании CSV-данных непосредственно в датафреймы (в объекты Dataframe). Иногда при загрузке данных формата CSV нужно указывать их кодировку (например, это может выглядеть как <code>encoding='ISO-8859–1'</code>). Это — первое, что стоит попробовать сделать в том случае, если оказывается, что после загрузки данных датафрейм содержит нечитаемые символы.<br>
<br>
<pre><code class="python">anime = pd.read_csv('anime-recommendations-database/anime.csv')
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/d5b59f543d887c33b912e66642640d9e.png"></div>
<br>
<i><font color="#999999">Загруженные CSV-данные</font></i><br>
<br>
Существует похожая функция для загрузки данных из Excel-файлов — <code>pd.read_excel</code>.<br>
<br>
<h3><font color="#3AC1EF">▍Создание датафрейма из данных, введённых вручную</font></h3>
<br>
Это может пригодиться тогда, когда нужно вручную ввести в программу простые данные. Например — если нужно оценить изменения, претерпеваемые данными, проходящими через конвейер обработки данных.<br>
<br>
<pre><code class="python">df = pd.DataFrame([[1,'Bob', 'Builder'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2,'Sally', 'Baker'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,'Scott', 'Candle Stick Maker']],&nbsp;
columns=['id','name', 'occupation'])
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/402bcb22ee99170d544f90fd64104289.png"></div>
<br>
<i><font color="#999999">Данные, введённые вручную</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Копирование датафрейма</font></h3>
<br>
Копирование датафреймов может пригодиться в ситуациях, когда требуется внести в данные изменения, но при этом надо и сохранить оригинал. Если датафреймы нужно копировать, то рекомендуется делать это сразу после их загрузки.<br>
<br>
<pre><code class="python">anime_copy = anime.copy(deep=True)
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/edd7c8e25b0d16a143659ca1462a186e.png"></div>
<br>
<i><font color="#999999">Копия датафрейма</font></i><br>
<br>
<h2><font color="#3AC1EF">3. Экспорт данных</font></h2>
<br>
<h3><font color="#3AC1EF">▍Экспорт в формат CSV</font></h3>
<br>
При экспорте данных они сохраняются в той же папке, где находится блокнот. Ниже показан пример сохранения первых 10 строк датафрейма, но то, что именно сохранять, зависит от конкретной задачи.<br>
<br>
<pre><code class="python">rating[:10].to_csv('saved_ratings.csv', index=False)
</code></pre>
<br>
Экспортировать данные в виде Excel-файлов можно с помощью функции <code>df.to_excel</code>.<br>
<br>
<h2><font color="#3AC1EF">4. Просмотр и исследование данных</font></h2>
<br>
<h3><font color="#3AC1EF">▍Получение n записей из начала или конца датафрейма</font></h3>
<br>
Сначала поговорим о выводе первых <code>n</code> элементов датафрейма. Я часто вывожу некоторое количество элементов из начала датафрейма где-нибудь в блокноте. Это позволяет мне удобно обращаться к этим данным в том случае, если я забуду о том, что именно находится в датафрейме. Похожую роль играет и вывод нескольких последних элементов.<br>
<br>
<pre><code class="python">anime.head(3)
rating.tail(1)
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/0f60619bb1a49bde2df4f171613dd193.png"></div>
<br>
<i><font color="#999999">Данные из начала датафрейма</font></i><br>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/85d2ad3933d300b6afbe8f3b3140f40d.png"></div>
<br>
<i><font color="#999999">Данные из конца датафрейма</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Подсчёт количества строк в датафрейме</font></h3>
<br>
Функция <code>len(),</code> которую я тут покажу, не входит в состав <code>pandas</code>. Но она хорошо подходит для подсчёта количества строк датафреймов. Результаты её работы можно сохранить в переменной и воспользоваться ими там, где они нужны.<br>
<br>
<pre><code class="python">len(df)
#=&gt; 3
</code></pre>
<br>
<h3><font color="#3AC1EF">▍Подсчёт количества уникальных значений в столбце</font></h3>
<br>
Для подсчёта количества уникальных значений в столбце можно воспользоваться такой конструкцией:<br>
<br>
<pre><code class="python">len(ratings['user_id'].unique())
</code></pre>
<br>
<h3><font color="#3AC1EF">▍Получение сведений о датафрейме</font></h3>
<br>
В сведения о датафрейме входит общая информация о нём вроде заголовка, количества значений, типов данных столбцов.<br>
<br>
<pre><code class="python">anime.info()
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/2f7ab56f1f7d431ef3e5f6ac7922c9a9.png"></div>
<br>
<i><font color="#999999">Сведения о датафрейме</font></i><br>
<br>
Есть ещё одна функция, похожая на <code>df.info</code> — <code>df.dtypes</code>. Она лишь выводит сведения о типах данных столбцов.<br>
<br>
<h3><font color="#3AC1EF">▍Вывод статистических сведений о датафрейме</font></h3>
<br>
Знание статистических сведений о датафрейме весьма полезно в ситуациях, когда он содержит множество числовых значений. Например, знание среднего, минимального и максимального значений столбца <code>rating</code> даёт нам некоторое понимание того, как, в целом, выглядит датафрейм. Вот соответствующая команда:<br>
<br>
<pre><code class="python">anime.describe()
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/bf52c0d4f50d357a40871a6999f2335f.png"></div>
<br>
<i><font color="#999999">Статистические сведения о датафрейме</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Подсчёт количества значений</font></h3>
<br>
Для того чтобы подсчитать количество значений в конкретном столбце, можно воспользоваться следующей конструкцией:<br>
<br>
<pre><code class="python">anime.type.value_counts()
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/3d251e47afdd01962810b0a1a8aa8859.png"></div>
<br>
<i><font color="#999999">Подсчёт количества элементов в столбце</font></i><br>
<br>
<h2><font color="#3AC1EF">5. Извлечение информации из датафреймов</font></h2>
<br>
<h3><font color="#3AC1EF">▍Создание списка или объекта Series на основе значений столбца</font></h3>
<br>
Это может пригодиться в тех случаях, когда требуется извлекать значения столбцов в переменные <code>x</code> и <code>y</code> для обучения модели. Здесь применимы следующие команды:<br>
<br>
<pre><code class="python">anime['genre'].tolist()
anime['genre']
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/c199fbd4cf50623d5fd75ded8f1614cc.png"></div>
<br>
<i><font color="#999999">Результаты работы команды anime['genre'].tolist()</font></i><br>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/e1f008ddfdb79459dad6f50421736c7b.png"></div>
<br>
<i><font color="#999999">Результаты работы команды anime['genre']</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Получение списка значений из индекса</font></h3>
<br>
Поговорим о получении списков значений из индекса. Обратите внимание на то, что я здесь использовал датафрейм <code>anime_modified</code>, так как его индексные значения выглядят интереснее.<br>
<br>
<pre><code class="python">anime_modified.index.tolist()
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/db377e121b77d871acdf9d1bc737069b.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Получение списка значений столбцов</font></h3>
<br>
Вот команда, которая позволяет получить список значений столбцов:<br>
<br>
<pre><code class="python">anime.columns.tolist()
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/685c1860f536fba854754c956107e3a7.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h2><font color="#3AC1EF">6. Добавление данных в датафрейм и удаление их из него</font></h2>
<br>
<h3><font color="#3AC1EF">▍Присоединение к датафрейму нового столбца с заданным значением</font></h3>
<br>
Иногда мне приходится добавлять в датафреймы новые столбцы. Например — в случаях, когда у меня есть тестовый и обучающий наборы в двух разных датафреймах, и мне, прежде чем их скомбинировать, нужно пометить их так, чтобы потом их можно было бы различить. Для этого используется такая конструкция:<br>
<br>
<pre><code class="python">anime['train set'] = True
</code></pre>
<br>
<h3><font color="#3AC1EF">▍Создание нового датафрейма из подмножества столбцов</font></h3>
<br>
Это может пригодиться в том случае, если требуется сохранить в новом датафрейме несколько столбцов огромного датафрейма, но при этом не хочется выписывать имена столбцов, которые нужно удалить.<br>
<br>
<pre><code class="python">anime[['name','episodes']]
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/8fe93102df79a85d02b6ef286049def5.png"></div>
<br>
<i><font color="#999999">Результат выполнения команды</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Удаление заданных столбцов</font></h3>
<br>
Этот приём может оказаться полезным в том случае, если из датафрейма нужно удалить лишь несколько столбцов. Если удалять нужно много столбцов, то эта задача может оказаться довольно-таки утомительной, поэтому тут я предпочитаю пользоваться возможностью, описанной в предыдущем разделе.<br>
<br>
<pre><code class="python">anime.drop(['anime_id', 'genre', 'members'], axis=1).head()
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/c7fbd8d5dff65dce484d873b497f31dc.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Добавление в датафрейм строки с суммой значений из других строк</font></h3>
<br>
Для демонстрации этого примера самостоятельно создадим небольшой датафрейм, с которым удобно работать. Самое интересное здесь — это конструкция <code>df.sum(axis=0)</code>, которая позволяет получать суммы значений из различных строк.&nbsp;<br>
<br>
<pre><code class="python">df = pd.DataFrame([[1,'Bob', 8000],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2,'Sally', 9000],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,'Scott', 20]], columns=['id','name', 'power level'])
df.append(df.sum(axis=0), ignore_index=True)
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/c7be91e10b1e31ee525dc26e44d2e9ea.png"></div>
<br>
<i><font color="#999999">Результат выполнения команды</font></i><br>
<br>
Команда вида <code>df.sum(axis=1)</code> позволяет суммировать значения в столбцах.<br>
<br>
Похожий механизм применим и для расчёта средних значений. Например — <code>df.mean(axis=0)</code>.<br>
<br>
<h2><font color="#3AC1EF">7. Комбинирование датафреймов</font></h2>
<br>
<h3><font color="#3AC1EF">▍Конкатенация двух датафреймов</font></h3>
<br>
Эта методика применима в ситуациях, когда имеются два датафрейма с одинаковыми столбцами, которые нужно скомбинировать.<br>
<br>
В данном примере мы сначала разделяем датафрейм на две части, а потом снова объединяем эти части:<br>
<br>
<pre><code class="python">df1 = anime[0:2]
df2 = anime[2:4]
pd.concat([df1, df2], ignore_index=True)
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/9b934f17234b988ded660c608413ab45.png"></div>
<br>
<i><font color="#999999">Датафрейм df1</font></i><br>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/3c65bb666ff3c7389c2b35cd2d4b3029.png"></div>
<br>
<i><font color="#999999">Датафрейм df2</font></i><br>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/68ba5d883c0b79be8a35a82296ba9dd9.png"></div>
<br>
<i><font color="#999999">Датафрейм, объединяющий df1 и df2</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Слияние датафреймов</font></h3>
<br>
Функция <code>df.merge</code>, которую мы тут рассмотрим, похожа на левое соединение SQL. Она применяется тогда, когда два датафрейма нужно объединить по некоему столбцу.<br>
<br>
<pre><code class="python">rating.merge(anime, left_on=’anime_id’, right_on=’anime_id’, suffixes=(‘_left’, ‘_right’))
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/f84b07bf1b7f835b21aebda6004a84e4.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h2><font color="#3AC1EF">8. Фильтрация</font></h2>
<br>
<h3><font color="#3AC1EF">▍Получение строк с нужными индексными значениями</font></h3>
<br>
Индексными значениями датафрейма <code>anime_modified</code> являются названия аниме. Обратите внимание на то, как мы используем эти названия для выбора конкретных столбцов.<br>
<br>
<pre><code class="python">anime_modified.loc[['Haikyuu!! Second Season','Gintama']]
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/77426631ebae515bef71c75fde3bd77b.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Получение строк по числовым индексам</font></h3>
<br>
Эта методика отличается от той, которая описана в предыдущем разделе. При использовании функции <code>df.iloc</code> первой строке назначается индекс <code>0</code>, второй — индекс <code>1</code>, и так далее. Такие индексы назначаются строкам даже в том случае, если датафрейм был модифицирован и в его индексном столбце используются строковые значения.<br>
<br>
Следующая конструкция позволяет выбрать три первых строки датафрейма:<br>
<br>
<pre><code class="python">anime_modified.iloc[0:3]
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/c775045fcf404c6e973a3bfd2aa32192.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Получение строк по заданным значениям столбцов</font></h3>
<br>
Для получения строк датафрейма в ситуации, когда имеется список значений столбцов, можно воспользоваться следующей командой:<br>
<br>
<pre><code class="python">anime[anime['type'].isin(['TV', 'Movie'])]
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/5d52f052b52c7054bd81c38bb2fe1128.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
Если нас интересует единственное значение — можно воспользоваться такой конструкцией:<br>
<br>
<pre><code class="python">anime[anime[‘type’] == 'TV']
</code></pre>
<br>
<h3><font color="#3AC1EF">▍Получение среза датафрейма</font></h3>
<br>
Эта техника напоминает получение среза списка. А именно, речь идёт о получении фрагмента датафрейма, содержащего строки, соответствующие заданной конфигурации индексов.<br>
<br>
<pre><code class="python">anime[1:3]
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/04e4cae8384f7484c380066d6f13d3ed.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Фильтрация по значению</font></h3>
<br>
Из датафреймов можно выбирать строки, соответствующие заданному условию. Обратите внимание на то, что при использовании этого метода сохраняются существующие индексные значения.<br>
<br>
<pre><code class="python">anime[anime['rating'] &gt; 8]
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/b2bc4a191c3178a18410ce592562b97a.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h2><font color="#3AC1EF">9. Сортировка</font></h2>
<br>
Для сортировки датафреймов по значениям столбцов можно воспользоваться функцией <code>df.sort_values</code>:<br>
<br>
<pre><code class="python">anime.sort_values('rating', ascending=False)
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/4caeae3c921af60b4d39fc9ef4947b43.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h2><font color="#3AC1EF">10. Агрегирование</font></h2>
<br>
<h3><font color="#3AC1EF">▍Функция df.groupby и подсчёт количества записей</font></h3>
<br>
Вот как подсчитать количество записей с различными значениями в столбцах:<br>
<br>
<pre><code class="python">anime.groupby('type').count()
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/092795c51d4be09e6f0211d5b14ef8ce.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Функция df.groupby и агрегирование столбцов различными способами</font></h3>
<br>
Обратите внимание на то, что здесь используется <code>reset_index()</code>. В противном случае столбец <code>type</code> становится индексным столбцом. В большинстве случаев я рекомендую делать то же самое.<br>
<br>
<pre><code class="python">anime.groupby(["type"]).agg({
&nbsp;&nbsp;"rating": "sum",
&nbsp;&nbsp;"episodes": "count",
&nbsp;&nbsp;"name": "last"
}).reset_index()
</code></pre>
<br>
<h3><font color="#3AC1EF">▍Создание сводной таблицы</font></h3>
<br>
Для того чтобы извлечь из датафрейма некие данные, нет ничего лучше, чем сводная таблица. Обратите внимание на то, что здесь я серьёзно отфильтровал датафрейм, что ускорило создание сводной таблицы.<br>
<br>
<pre><code class="python">tmp_df = rating.copy()
tmp_df.sort_values('user_id', ascending=True, inplace=True)
tmp_df = tmp_df[tmp_df.user_id &lt; 10]&nbsp;
tmp_df = tmp_df[tmp_df.anime_id &lt; 30]
tmp_df = tmp_df[tmp_df.rating != -1]
pd.pivot_table(tmp_df, values='rating', index=['user_id'], columns=['anime_id'], aggfunc=np.sum, fill_value=0)
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/2912d74af64b3e114e543433d482eb6e.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h2><font color="#3AC1EF">11. Очистка данных</font></h2>
<br>
<h3><font color="#3AC1EF">▍Запись в ячейки, содержащие значение NaN, какого-то другого значения</font></h3>
<br>
Здесь мы поговорим о записи значения <code>0</code> в ячейки, содержащие значение <code>NaN</code>. В этом примере мы создаём такую же сводную таблицу, как и ранее, но без использования <code>fill_value=0</code>. А затем используем функцию <code>fillna(0)</code> для замены значений <code>NaN</code> на <code>0</code>.<br>
<br>
<pre><code class="python">pivot = pd.pivot_table(tmp_df, values='rating', index=['user_id'], columns=['anime_id'], aggfunc=np.sum)
pivot.fillna(0)
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/39562f618aba5dadee84f65c5eec1de6.png"></div>
<br>
<i><font color="#999999">Таблица, содержащая значения NaN</font></i><br>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/ca5c889ce4fcaeefcf6073a53a854800.png"></div>
<br>
<i><font color="#999999">Результаты замены значений NaN на 0</font></i><br>
<br>
<h2><font color="#3AC1EF">12. Другие полезные возможности</font></h2>
<br>
<h3><font color="#3AC1EF">▍Отбор случайных образцов из набора данных</font></h3>
<br>
Я использую функцию <code>df.sample</code> каждый раз, когда мне нужно получить небольшой случайный набор строк из большого датафрейма. Если используется параметр <code>frac=1</code>, то функция позволяет получить аналог исходного датафрейма, строки которого будут перемешаны.<br>
<br>
<pre><code class="python">anime.sample(frac=0.25)
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/1960bb0441f16d1f5a637f53125b0133.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Перебор строк датафрейма</font></h3>
<br>
Следующая конструкция позволяет перебирать строки датафрейма:<br>
<br>
<pre><code class="python">for idx,row in anime[:2].iterrows():
&nbsp;&nbsp;&nbsp;&nbsp;print(idx, row)
</code></pre>
<br>
<div style="text-align:center;"><img src="./Моя шпаргалка по pandas_files/e3e1d6d24c6b3ef1797cbfb64dfebc6b.png"></div>
<br>
<i><font color="#999999">Результаты выполнения команды</font></i><br>
<br>
<h3><font color="#3AC1EF">▍Борьба с ошибкой IOPub data rate exceeded</font></h3>
<br>
Если вы сталкиваетесь с ошибкой <code>IOPub data rate exceeded</code> — попробуйте, при запуске Jupyter Notebook, воспользоваться следующей командой:<br>
<br>
<pre><code class="python">jupyter notebook — NotebookApp.iopub_data_rate_limit=1.0e10
</code></pre>
<br>
<h2><font color="#3AC1EF">Итоги</font></h2>
<br>
Здесь я рассказал о некоторых полезных приёмах использования <code>pandas</code> в среде Jupyter Notebook. Надеюсь, моя шпаргалка вам пригодится.<br>
<br>
<b>Уважаемые читатели!</b> Есть ли какие-нибудь возможности <code>pandas</code>, без которых вы не представляете своей повседневной работы?<br>
<br>
<a href="https://ruvds.com/ru-rub/#order"><img src="./Моя шпаргалка по pandas_files/iqfib45pgphfrxv--zfemt0qnmw.jpeg"></a>
</div>
       
       <div class="ad2">
           <!-- Yandex.RTB R-A-469165-2 -->
           <div id="yandex_rtb_R-A-469165-2"></div>
           <script type="text/javascript">
               (function(w, d, n, s, t) {
                   w[n] = w[n] || [];
                   w[n].push(function() {
                       Ya.Context.AdvManager.render({
                           blockId: "R-A-469165-2",
                           renderTo: "yandex_rtb_R-A-469165-2",
                           async: true
                       });
                   });
                   t = d.getElementsByTagName("script")[0];
                   s = d.createElement("script");
                   s.type = "text/javascript";
                   s.src = "//an.yandex.ru/system/context.js";
                   s.async = true;
                   t.parentNode.insertBefore(s, t);
               })(this, this.document, "yandexContextAsyncCallbacks");
           </script>
        
    </div>
    <script>
    particlesJS('particles-js',

  {
    "particles": {
      "number": {
        "value": 50,
        "density": {
          "enable": true,
          "value_area": 400
        }
      },
      "color": {
        "value": "#333"
      },
      "shape": {
        "type": "circle",
        "stroke": {
          "width": 0,
          "color": "#000000"
        },
        "polygon": {
          "nb_sides": 5
        },
        "image": {
          "src": "img/github.svg",
          "width": 100,
          "height": 100
        }
      },
      "opacity": {
        "value": 0.5,
        "random": false,
        "anim": {
          "enable": false,
          "speed": 1,
          "opacity_min": 0.1,
          "sync": false
        }
      },
      "size": {
        "value": 5,
        "random": true,
        "anim": {
          "enable": false,
          "speed": 40,
          "size_min": 0.1,
          "sync": false
        }
      },
      "line_linked": {
        "enable": true,
        "distance": 150,
        "color": "#333",
        "opacity": 0.4,
        "width": 1
      },
      "move": {
        "enable": true,
        "speed": 6,
        "direction": "none",
        "random": false,
        "straight": false,
        "out_mode": "out",
        "attract": {
          "enable": false,
          "rotateX": 600,
          "rotateY": 1200
        }
      }
    },
    "interactivity": {
      "detect_on": "canvas",
      "events": {
        "onhover": {
          "enable": true,
          "mode": "repulse"
        },
        "onclick": {
          "enable": true,
          "mode": "push"
        },
        "resize": true
      },
      "modes": {
        "grab": {
          "distance": 400,
          "line_linked": {
            "opacity": 1
          }
        },
        "bubble": {
          "distance": 400,
          "size": 20,
          "duration": 2,
          "opacity": 8,
          "speed": 3
        },
        "repulse": {
          "distance": 200
        },
        "push": {
          "particles_nb": 4
        },
        "remove": {
          "particles_nb": 2
        }
      }
    },
    "retina_detect": true,
    "config_demo": {
      "hide_card": false,
      "background_color": "#b61924",
      "background_image": "",
      "background_position": "50% 50%",
      "background_repeat": "no-repeat",
      "background_size": "cover"
    }
  }

);
    </script>

</div></body></html>